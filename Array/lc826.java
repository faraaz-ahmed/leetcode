//826. Most Profit Assigning Work//        Solved//        Medium//        Topics//        Companies//        You have n jobs and m workers. You are given three arrays: difficulty, profit, and worker where:////        difficulty[i] and profit[i] are the difficulty and the profit of the ith job, and//        worker[j] is the ability of jth worker (i.e., the jth worker can only complete a job with difficulty at most worker[j]).//        Every worker can be assigned at most one job, but one job can be completed multiple times.////        For example, if three workers attempt the same job that pays $1, then the total profit will be $3. If a worker cannot complete any job, their profit is $0.//        Return the maximum profit we can achieve after assigning the workers to the jobs.////////        Example 1:////        Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]//        Output: 100//        Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get a profit of [20,20,30,30] separately.//        Example 2:////        Input: difficulty = [85,47,57], profit = [24,66,99], worker = [40,25,25]//        Output: 0//////        Constraints:////        n == difficulty.length//        n == profit.length//        m == worker.length//        1 <= n, m <= 104//        1 <= difficulty[i], profit[i], worker[i] <= 105package Array;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.TreeMap;public class lc826 {    class Solution {        public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {            TreeMap<Integer, Integer> treeMap = new TreeMap<>();            for (int i = 0; i < difficulty.length; i++) {                treeMap.put(difficulty[i], Math.max(profit[i], treeMap.getOrDefault(difficulty[i], 0)));            }            Arrays.sort(worker);            Integer maxSoFar = 0;            for (Integer key: treeMap.keySet()) {                if (treeMap.get(key) > maxSoFar) {                    maxSoFar = treeMap.get(key);                } else {                    treeMap.put(key, maxSoFar);                }            }            int result = getResult(worker, treeMap);            return result;        }        private static int getResult(int[] worker, TreeMap<Integer, Integer> treeMap) {            int i = worker.length - 1;            int result = 0;            List<Integer> sortedKeys = new ArrayList(treeMap.keySet());            int j = sortedKeys.size() - 1;            while (i >= 0) {                while (j >= 0) {                    if (sortedKeys.get(j) > worker[i]) {                        j--;                    } else {                        result += j >= 0 ? treeMap.getOrDefault(sortedKeys.get(j),0) : 0;                        break;                    }                }                i--;            }            return result;        }    }}