package Trees;import java.util.ArrayList;import java.util.Arrays;import java.util.HashMap;import java.util.List;public class lc95 {    class Solution {        HashMap<String, List<TreeNode>> nodeMap = new HashMap<>();        public void putInMap(int left, int right, List<TreeNode> treeNodes) {            nodeMap.put(STR."\{left} \{right}", treeNodes);        }        public List<TreeNode> getFromMap(int left, int right) {            return nodeMap.get(STR."\{left} \{right}");        }        public Boolean checkIfExistsInMap(int left, int right) {            return nodeMap.containsKey(STR."\{left} \{right}");        }        public List<TreeNode> dfs(int left, int right) {//            commenting out map makes it more efficient from 10% to 90% because theres no consecutive retrivals of//            the same key//            if (checkIfExistsInMap(left, right)) {//                return getFromMap(left, right);//            }            if (left > right) {                List<TreeNode> treeNodes = new ArrayList<>();                treeNodes.add(null);                return treeNodes;            }            if (left == right) return Arrays.asList(new TreeNode(left));            List<TreeNode> answer = new ArrayList<>();            for (int root = left; root <= right; root++) {                List<TreeNode> leftNodes = dfs(left, root - 1);                List<TreeNode> rightNodes = dfs(root + 1, right);                for (int i = 0; i < leftNodes.size(); i++) {                    for (int j = 0; j < rightNodes.size(); j++) {                        TreeNode rootNode = new TreeNode(root, leftNodes.get(i), rightNodes.get(j));                        answer.add(rootNode);                    }                }            }//            putInMap(left, right, answer);            return answer;        }        public List<TreeNode> generateTrees(int n) {            return dfs(1, n);        }    }}//public void insertIntoBST(TreeNode root, int value) {//    while (root != null ) {//        if (root.val > value) {//            if (root.left == null) {//                root.left = new TreeNode(value);//            }//            insertIntoBST(root.left, value);//        } else {//            if (root.right == null) {//                root.right = new TreeNode(value);//            }//            insertIntoBST(root.right, value);//        }////    }//}//        public List<TreeNode> generateTreesWorker(int start, int end) {//            for (int i = start; i <= end; i++) {////            }//        }